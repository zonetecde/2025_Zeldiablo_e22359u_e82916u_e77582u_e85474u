@startuml
title Diagramme de classes final - Zeldiablo

abstract class Entite {
    - x: int
    - y: int
    - hp: double
    - maxHp: double
    - degat: double
    - enVie: boolean
    + Entite(dx: int, dy: int, maxHp: double, degat: double)
    + etrePresent(dx: int, dy: int): boolean
    + prendreDegat(d: double): void
    + mettreDegat(cible: Entite): void
    + estMort(): boolean
}

class Monstre {
    + Monstre(x: int, y: int, pv: double, degat: double, intelligence: Intelligence)
    + deplacer(laby: Labyrinthe): void
    + getDeplacementStrategie(): DeplacementStrategie
    + setDeplacementStrategie(deplacementStrategie: DeplacementStrategie): void
}

class MonstreStatique {
}

class Player {
    - aGagne: boolean
    - sprite: int
    + Player(dx: int, dy: int, maxHp: double, degat: double)
    + setSpriteJoueur(i: int): void
    + getSpriteJoueur(): int
    + setEnVie(b: boolean): void
    + getInventaireObjet(): Inventaire
    + getVie(): double
    + mettreDegat(cible: Entite): void
    + aGagne(): boolean
    + possedeItem(nomItem: String): boolean
}

class Inventaire {
    + Inventaire()
    + Inventaire(items: ArrayList<Item>)
    + ajouterItem(item: Item): void
    + getItems(): ArrayList<Item>
    + setItems(items: ArrayList<Item>): void
    + size(): int
    + get(index: int): Item
    + vider(): void
    + possedeItem(nomItem: String): boolean
}

abstract class Item {
    - name: String
    - type: TypeItem
    - params: Object[]
    + Item(name: String, img: String, type: TypeItem)
    + getName(): String
    + getType(): TypeItem
    + getParams(): Object[]
    + toString(): String
    + {abstract} getDegat(): double
}

abstract class Arme {
    # degat: double
    + Arme(name: String, img: String, degat: double)
    + getDegat(): double
}

class Epee {
    + Epee()
}

class Hache {
    + Hache()
}

class Baton {
    + Baton()
}

class Food {
    + Food()
    + use(laby: Labyrinthe): boolean
    + getDegat(): double
}

class ItemDefault {
    + ItemDefault()
    + ItemDefault(name: String)
    + getDegat(): double
}

class Amulette {
    + Amulette()
    + getDegat(): double
}

interface Action {
    + onStepOn(Entite entite): void
    + onAction(Entite entite, ZeldiabloJeu jeu): void
}

abstract class Case {
    - x: int
    - y: int
    - couleur: Color
    - isWalkable: boolean
    + Case(x: int, y: int, couleur: Color, isWalkable: boolean, img: String)
    + addItem(item: Item): void
    + hasItem(): boolean
    + removeItem(): void
    + getItem(): Item
    + onStepOn(Entite entite): void
    + onAction(Entite entite, ZeldiabloJeu jeu): void
}

class CaseEscalier {
    + onAction(Entite entite, ZeldiabloJeu jeu): void
}

class CaseMur {
}

class CaseOuverture {
    - action: Runnable
    + CaseOuverture(int x, int y, Runnable action)
    + onStepOn(Entite entite): void
}

class CasePancarte {
    + onStepOn(Entite entite): void
}

class CasePiege {
    - degats: int
    + onStepOn(Entite entite): void
    + getDegats(): double
}

class CasePorte {
    - ouverte: boolean
    + ouvrir(): void
}

class CaseVide {
    + hasItem(): boolean
    + removeItem(): void
    + addItem(Item item): void
    + getItem(): Item
}

interface DeplacementStrategie {
    + deplacement(laby: Labyrinthe, monstre: Monstre): void
}

class DeplacementStatique {
    + deplacement(labyrinthe: Labyrinthe, monstre: Monstre): void
}

class DeplacementHasard {
    + deplacement(laby: Labyrinthe, monstre: Monstre): void
}

class DeplacementRapprochement {
    + deplacement(labyrinthe: Labyrinthe, monstre: Monstre): void
}

class DeplacementIntelligent {
    + deplacement(labyrinthe: Labyrinthe, monstre: Monstre): void
    - calculerDistance(x1: int, y1: int, x2: int, y2: int): double
}

class DeplacementFuyard {
    + deplacement(labyrinthe: Labyrinthe, monstre: Monstre): void
}

class Labyrinthe {
    - longueur: int
    - hauteur: int
    - casePorte: CasePorte
    + Labyrinthe(String nom, ZeldiabloJeu jeu)
    + getCase(int y, int x): Case
    + canEntityMoveTo(int i, int j): boolean
    + deplacerPerso(Direction action, Entite p): void
    + etreFini(): boolean
    + ramasserItem(Player joueur): void
}

class ZeldiabloJeu {
    + ZeldiabloJeu()
    + evoluer(Commande commandeUtilisateur): void
    + etreFini(): boolean
}

class ZeldiabloDessin {
    + ZeldiabloDessin()
    + dessiner(BufferedImage image): void
}

class MainZeldiablo {
    + main(String[] args): void
}

class Sprite {
    - imgFile: String
    - img: Image
    + Sprite(s: String)
    + setImg(img: String): void
    + getImg(): Image
}

enum TypeItem {
    OBJET
    ARME
    MISC
}

enum Intelligence {
    NULLE
    FAIBLE
    MOYENNE
    FORTE
}

Entite <|-- Monstre
Entite <|-- Player
Monstre <|-- MonstreStatique

Item <|-- Arme
Item <|-- Food
Item <|-- ItemDefault
Item <|-- Amulette
Arme <|-- Epee
Arme <|-- Hache
Arme <|-- Baton

Case ..|> Action
Case <|-- CaseEscalier
Case <|-- CaseMur
Case <|-- CaseOuverture
Case <|-- CasePancarte
Case <|-- CasePiege
Case <|-- CasePorte
Case <|-- CaseVide

DeplacementStrategie <|.. DeplacementStatique
DeplacementStrategie <|.. DeplacementHasard
DeplacementStrategie <|.. DeplacementRapprochement
DeplacementStrategie <|.. DeplacementIntelligent
DeplacementStrategie <|.. DeplacementFuyard

Labyrinthe "1" --> "*" Case : gameBoard
Labyrinthe "1" --> "*" Monstre : monstres
Labyrinthe "1" --> "1" Player : joueur
Monstre "1" --> "1" DeplacementStrategie : deplacementStrategie
Player "1" --> "1" Inventaire : inventaire
Inventaire "1" --> "*" Item : items
CaseVide "1" --> "0..1" Item : item

Item --> Sprite : sprite
Entite --> Sprite : sprite
Case --> Sprite : sprite

Item ..> TypeItem : utilise
Monstre ..> Intelligence : utilise

ZeldiabloJeu --> Labyrinthe
MainZeldiablo --> ZeldiabloJeu
MainZeldiablo --> ZeldiabloDessin

@enduml
